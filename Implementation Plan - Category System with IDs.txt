ðŸ“‹ RADICAL Implementation Plan: Professional Accounts System (SaaS-Grade)

  Executive Summary

  Complete replacement of category system with professional Chart of Accounts. 
  NO MIGRATION - Full rebuild with dummy data. Downtime acceptable.
  Target: Production-ready SaaS backend in 5 days.

  ---
  Phase 1: DESTROY & REBUILD [Day 1]

  1.1 Delete All Legacy Structure

  accounts (Replaces categories + subcategories)

  {
    account_id: "ACC-001",           // Primary identifier
    account_number: "5100",           // Optional numeric code
    name: "Office Supplies",
    type: "expense",                  // expense/income/asset/liability
    parent_id: null | "ACC-000",      // null = top level, otherwise parent account
    level: 1,                          // 1 = category, 2 = subcategory

    // Properties
    active: true,
    description: "Office and administrative supplies",
    tax_code: "STANDARD",

    // Budget & Controls
    budget_monthly: 5000,
    approval_required: false,
    approval_threshold: 1000,

    // Metadata
    created_at: Timestamp,
    created_by: "user_id",
    updated_at: Timestamp,
    updated_by: "user_id",

    // Legacy mapping (temporary during migration)
    _legacy: {
      old_category_id: "CAT-001",
      old_subcategory_id: "SUB-003",
      old_category_name: "Operations",
      old_subcategory_name: "Office Supplies"
    }
  }

  account_mappings (New - for quick lookups)

  {
    mapping_id: "MAP-001",
    account_id: "ACC-001",
    mapping_type: "quickbooks_import",  // or "legacy_id", "external_system"
    external_id: "6100",                 // QuickBooks account number
    external_name: "Office Supplies",
    created_at: Timestamp
  }

  1.2 Updated Transaction Structure

  // BEFORE (current)
  transaction = {
    category: "Operations",        // Name-based
    subcategory: "Office Supplies",
    category_id: "CAT-001",       // Redundant
    subcategory_id: "SUB-003"     // Redundant
  }

  // AFTER (professional)
  transaction = {
    account_id: "ACC-001",         // Single source of truth
    // No names stored - looked up when needed

    // During migration, temporary fields:
    _migration: {
      old_category: "Operations",
      old_subcategory: "Office Supplies",
      migrated_at: Timestamp
    }
  }

  ---
  Phase 2: Backend Implementation [Week 1-2]

  2.1 New API Endpoints

  // Account Management
  GET    /api/accounts              // List all accounts (with hierarchy)
  GET    /api/accounts/:id          // Get single account
  POST   /api/accounts              // Create account
  PUT    /api/accounts/:id          // Update account (auto-propagates)
  DELETE /api/accounts/:id          // Soft delete (make inactive)
  POST   /api/accounts/:id/merge    // Merge accounts

  // Account Hierarchy
  GET    /api/accounts/tree         // Full hierarchy tree
  POST   /api/accounts/:id/move     // Move to different parent

  // Lookups
  GET    /api/accounts/lookup?name=Office+Supplies  // Find by name
  GET    /api/accounts/search?q=office              // Search accounts

  2.2 Core Functions to Implement

  // functions/index.js additions

  async function createAccount(uid, accountData) {
    const accountId = await generateAccountId(uid);

    const account = {
      account_id: accountId,
      account_number: accountData.account_number || generateAccountNumber(),
      name: accountData.name,
      type: accountData.type || 'expense',
      parent_id: accountData.parent_id || null,
      level: accountData.parent_id ? 2 : 1,
      active: true,
      created_at: Timestamp.now(),
      created_by: uid
    };

    await db.collection('users').doc(uid)
      .collection('accounts').doc(accountId).set(account);

    return accountId;
  }

  async function renameAccount(uid, accountId, newName) {
    // Just update the account - no propagation needed!
    await db.collection('users').doc(uid)
      .collection('accounts').doc(accountId)
      .update({
        name: newName,
        updated_at: Timestamp.now()
      });

    // That's it! All transactions automatically show new name
  }

  async function getAccountName(uid, accountId) {
    // Cache this heavily - it's called frequently
    const doc = await db.collection('users').doc(uid)
      .collection('accounts').doc(accountId).get();
    return doc.exists ? doc.data().name : 'Unknown Account';
  }

  ---
  Phase 3: Migration Strategy [Week 2]

  3.1 Migration Script

  async function migrateToAccounts(uid) {
    const batch = db.batch();
    const accountMap = new Map(); // old_id -> new_id

    // Step 1: Migrate categories to parent accounts
    const categories = await db.collection('users').doc(uid)
      .collection('categories').get();

    for (const catDoc of categories.docs) {
      const cat = catDoc.data();
      const newAccountId = `ACC-${cat.category_id.substring(4)}`; // CAT-001 -> ACC-001

      const parentAccount = {
        account_id: newAccountId,
        name: cat.name,
        type: 'expense',
        parent_id: null,
        level: 1,
        active: cat.active !== false,
        _legacy: {
          old_category_id: cat.category_id,
          old_category_name: cat.name
        }
      };

      batch.set(
        db.collection('users').doc(uid).collection('accounts').doc(newAccountId),
        parentAccount
      );

      accountMap.set(cat.category_id, newAccountId);

      // Step 2: Migrate subcategories to child accounts
      if (cat.subcategories) {
        for (const sub of cat.subcategories) {
          const subAccountId = `ACC-${sub.id.substring(4)}`; // SUB-001 -> ACC-001

          const childAccount = {
            account_id: subAccountId,
            name: sub.name,
            type: 'expense',
            parent_id: newAccountId,
            level: 2,
            active: true,
            _legacy: {
              old_category_id: cat.category_id,
              old_subcategory_id: sub.id,
              old_category_name: cat.name,
              old_subcategory_name: sub.name
            }
          };

          batch.set(
            db.collection('users').doc(uid).collection('accounts').doc(subAccountId),
            childAccount
          );

          accountMap.set(`${cat.category_id}:${sub.id}`, subAccountId);
        }
      }
    }

    await batch.commit();

    // Step 3: Update all transactions
    const transactions = await db.collection('users').doc(uid)
      .collection('all-transactions').get();

    const txBatch = db.batch();
    let count = 0;

    for (const txDoc of transactions.docs) {
      const tx = txDoc.data();
      const updates = {};

      // Find the right account ID
      if (tx.subcategory_id) {
        const mapKey = `${tx.category_id}:${tx.subcategory_id}`;
        updates.account_id = accountMap.get(mapKey);
      } else if (tx.category_id) {
        updates.account_id = accountMap.get(tx.category_id);
      }

      if (updates.account_id) {
        updates._migration = {
          old_category: tx.category,
          old_subcategory: tx.subcategory,
          old_category_id: tx.category_id,
          old_subcategory_id: tx.subcategory_id,
          migrated_at: Timestamp.now()
        };

        txBatch.update(txDoc.ref, updates);
        count++;

        if (count % 500 === 0) {
          await txBatch.commit();
          txBatch = db.batch();
        }
      }
    }

    if (count % 500 !== 0) {
      await txBatch.commit();
    }

    return { migrated: count, accounts: accountMap.size };
  }

  3.2 Migration Steps

  1. Create backup
  firebase firestore:export gs://budget-backup-$(date +%Y%m%d)
  2. Run migration in test environment
  await migrateToAccounts('test-user-id');
  3. Validate migration
  await validateMigration('test-user-id');
  4. Deploy new code (with backward compatibility)
  5. Run production migration (user by user)
  6. Remove legacy fields (after 30 days)

  ---
  Phase 4: Frontend Updates [Week 2-3]

  4.1 Update Transaction Display

  // OLD: Uses names directly
  function displayTransaction(tx) {
    return `${tx.category} - ${tx.subcategory}: $${tx.amount}`;
  }

  // NEW: Looks up names from accounts
  async function displayTransaction(tx) {
    const account = await getAccount(tx.account_id);
    const parent = account.parent_id ? await getAccount(account.parent_id) : null;

    if (parent) {
      return `${parent.name} - ${account.name}: $${tx.amount}`;
    }
    return `${account.name}: $${tx.amount}`;
  }

  4.2 Update Category Selector

  // New hierarchical selector component
  function AccountSelector({ onSelect, currentAccountId }) {
    const [accounts, setAccounts] = useState([]);
    const [expanded, setExpanded] = useState(new Set());

    useEffect(() => {
      loadAccountTree().then(setAccounts);
    }, []);

    return (
      <div className="account-tree">
        {accounts.map(parent => (
          <div key={parent.account_id}>
            <div onClick={() => toggle(parent.account_id)}>
              {expanded.has(parent.account_id) ? 'â–¼' : 'â–¶'}
              {parent.name}
            </div>
            {expanded.has(parent.account_id) && (
              <div className="children">
                {parent.children.map(child => (
                  <div 
                    key={child.account_id}
                    onClick={() => onSelect(child.account_id)}
                    className={currentAccountId === child.account_id ? 'selected' : ''}
                  >
                    {child.name}
                  </div>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    );
  }

  ---
  Phase 5: Testing & Validation [Week 3]

  5.1 Test Cases

  describe('Account System Tests', () => {
    test('Renaming account updates all displays', async () => {
      const accountId = await createAccount({ name: 'Office Supplies' });
      const txId = await createTransaction({ account_id: accountId });

      await renameAccount(accountId, 'Office & Admin Supplies');

      const txDisplay = await getTransactionDisplay(txId);
      expect(txDisplay).toContain('Office & Admin Supplies');
    });

    test('Moving account preserves transactions', async () => {
      const child = await createAccount({
        name: 'Supplies',
        parent_id: 'ACC-001'
      });

      await moveAccount(child.account_id, 'ACC-002'); // New parent

      const transactions = await getAccountTransactions(child.account_id);
      expect(transactions.length).toBeGreaterThan(0);
    });

    test('Merging accounts combines transactions', async () => {
      const result = await mergeAccounts('ACC-001', 'ACC-002');
      expect(result.transferred_transactions).toBeGreaterThan(0);
    });
  });

  5.2 Validation Queries

  -- Check all transactions have valid account_id
  SELECT COUNT(*) FROM transactions
  WHERE account_id IS NULL
  OR account_id NOT IN (SELECT account_id FROM accounts)

  -- Verify no orphaned subcategories
  SELECT * FROM accounts
  WHERE parent_id IS NOT NULL
  AND parent_id NOT IN (SELECT account_id FROM accounts WHERE parent_id IS NULL)

  -- Check for duplicate account names at same level
  SELECT parent_id, name, COUNT(*)
  FROM accounts
  GROUP BY parent_id, name
  HAVING COUNT(*) > 1

  ---
  Phase 6: Rollback Plan [If Needed]

  6.1 Rollback Script

  async function rollbackToLegacy(uid) {
    // Restore from _migration fields
    const transactions = await db.collection('users').doc(uid)
      .collection('all-transactions')
      .where('_migration', '!=', null)
      .get();

    const batch = db.batch();

    transactions.forEach(doc => {
      const migration = doc.data()._migration;
      batch.update(doc.ref, {
        category: migration.old_category,
        subcategory: migration.old_subcategory,
        category_id: migration.old_category_id,
        subcategory_id: migration.old_subcategory_id,
        account_id: FieldValue.delete(),
        _migration: FieldValue.delete()
      });
    });

    await batch.commit();
  }

  ---
  Timeline & Milestones

  | Week | Phase                | Deliverables          | Success Criteria                |
  |------|----------------------|-----------------------|---------------------------------|
  | 1    | Database Design      | New schema deployed   | Accounts collection created     |
  | 1-2  | Backend APIs         | All endpoints working | Tests pass 100%                 |
  | 2    | Migration Script     | Script tested         | Test data migrated successfully |
  | 2-3  | Frontend Updates     | UI using new APIs     | No visible changes to users     |
  | 3    | Testing              | All tests passing     | <0.1% error rate                |
  | 4    | Production Migration | All users migrated    | Zero data loss                  |
  | 5    | Cleanup              | Legacy code removed   | Code 30% smaller                |

  ---
  Risk Mitigation

  | Risk                       | Impact | Mitigation                                    |
  |----------------------------|--------|-----------------------------------------------|
  | Data loss during migration | High   | Full backup before migration, test on staging |
  | Performance degradation    | Medium | Add caching layer for account lookups         |
  | User confusion             | Low    | No UI changes initially, gradual rollout      |
  | Rollback needed            | Medium | Keep legacy fields for 30 days                |

  ---
  Success Metrics

  - âœ… Zero data loss during migration
  - âœ… 100% of transactions properly linked to accounts
  - âœ… < 50ms account lookup time (with cache)
  - âœ… 50% reduction in category-related bugs
  - âœ… 3x faster bulk operations
  - âœ… Compliance ready for audit trails

  ---
  Next Steps

  1. Review and approve this plan
  2. Set up test environment with copy of production data
  3. Begin Phase 1 implementation
  4. Weekly progress reviews during implementation

  This plan transforms your system to match QuickBooks' professional standards while maintaining full backward compatibility during the transition.